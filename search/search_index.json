{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Praktis dbt","text":"<p>\ud83d\udccc Author: Rendy B. Junior \ud83d\udce2 Feedback? Open an issue on GitHub.</p>"},{"location":"chapter-1/analyses/","title":"Analyses","text":"<p>Saat kita melakukan analisis, seringkali tidak untuk digunakan sebagai model dan tidak perlu dibuatkan tabelnya. Analysis hanya perlu di-compile untuk mendapatkan SQL query yang kemudian digunakan di BI tools untuk visualisasi.</p> <p>Analisis dibuat dengan menggunakan SQL file biasa, namun ditaruh dalam folder <code>analyses</code>, misalnya <code>analyses/running_total_by_account.sql</code>. Hasil kompilasi file SQL-nya bisa ditemukan di <code>target/compiled/{project name}/analyses/running_total_by_account.sql</code>.</p> <p>Kapan menggunakan analyses?</p> <p>Mengetik dan meng-compile di dbt merupakan hal yang merepotkan, apalagi perlu mencari di mana file hasil compile-nya. Penggunaannya yang memudahkan adalah untuk mencari tahu dengan lengkap alamat dari sebuah model (database, schema, dan nama tabelnya) saat kita lupa. Misalnya <code>{{ ref('quickbooks_adjusted_journal_entries') }}</code> menjadi <code>dbt.finance.adjusted_journal</code>.</p> <p>Jika tidak menggunakan analyses, kita perlu mencari alamat lengkap hasil pemrosesan dengan langkah-langkah di bawah ini. Cukup merepotkan kalau belum hafal.</p> <p>Cara mengetahui alamat lengkap hasil materialisasi model: - database-nya di mana, dengan melihat   - <code>&lt;project&gt;.outputs.&lt;target&gt;.database</code> di <code>profiles.yml</code>, atau   - di level model di <code>dbt_project.yml</code> di <code>models.&lt;project&gt;.&lt;folder&gt;.+database</code>. - schema-nya di mana, caranya sama dengan database (lihat poin sebelumnya), dan - tabel-nya di mana, dengan melihat   - nama model di <code>models.name</code> di yaml model, yang sama dengan nama file sql model-nya,   - value <code>alias</code> di <code>models.alias</code> di yaml model   - melihat apakah ada macro <code>generate_alias_name</code>, misal seperti di bawah ini. Jika ada macro dengan nama tersebut, dbt akan otomatis memanggilnya untuk mendapatkan nama alias secara programatik.</p> <pre><code>{% macro generate_alias_name(custom_alias, node) -%}\n    {# If an alias is defined in schema.yml, use it #}\n    {% if custom_alias is not none %}\n        {{ custom_alias }}\n    {% else %}\n        {# Otherwise, add a \"dbt_\" prefix to the model name #}\n        dbt_{{ node.name }}\n    {% endif %}\n{%- endmacro %}\n</code></pre>"},{"location":"chapter-1/project/","title":"Project","text":"<p>Project adalah satuan paling tinggi dalam dbt, ditandai dengan sebuah folder dan sebuah yaml configuration didalamnya <code>project.yml</code>. - Satu project tidak bisa berhubungan dengan project yang lain, modelnya tidak bisa direferensikan. - Satu project hanya bisa terhubung dengan satu database</p> <p>Kapan pisah project? - Kalau data dan transformasinya sensitif dan perlu pisah repo, manajemen akses dan security - beda team (arguably masih oke satu project beda tim di beda folder) - beda schedule (arguably masih bisa pakai select utk beda schedule) - beda database, misal satu dbt ada di postgres lalu dilanjutkan di snowflake - beda ritme development, misal jika mau rollback dan salah satu domain terlalu aktif, jadi sulit rollbacknya (alasan terkuat untuk beda tim beda project)</p>"},{"location":"chapter-1/project/#layering","title":"Layering","text":"<ul> <li>source</li> <li>staging, hanya refer ke source, tugasnya join2 data</li> <li>warehouse, hanya refer ke staging</li> <li>mart, hanya refer ke warehouse</li> </ul>"},{"location":"chapter-1/source/","title":"Source","text":"<p>Source adalah bahan mentah pemrosesan yang berasal dari sumber data, dipanggil dalam SQL dengan menggunakan <code>{{source('nama_source', 'nama_table')}}</code></p> <p>Misal kita buat file dalam folder <code>model/&lt;filename&gt;.yml</code> dengan isi sebagai berikut. <pre><code>sources:\n  - name: jaffle_shop\n    database: raw  \n    schema: jaffle_shop  \n    tables:\n      - name: orders\n</code></pre> Artinya kita bisa memanggil table <code>raw.orders</code> dengan <code>{{ source('jaffle_shop', 'orders')}}</code>. Tips: Sources bisa dikumpulkan di satu folder <code>model/sources/*_sources.yml</code> Tips: Sources bisa dinamakan <code>sources.yml</code> jika hanya satu source, atau <code>&lt;sesuatu&gt;_sources.yml</code>. Akan lebih baik jika bisa membedakan dari sistem mana data ini diambil dari namanya. Tips: Supaya tidak bingung dengan alias source, sebaiknya nama source dinamakan dengan <code>&lt;database&gt;_&lt;schema&gt;</code>, misal pada contoh di atas menjadi <code>raw_jaffle_shop</code> Counter Tips: Tapi gimana kalau sumbernya ganti table saja? Seharusnya namanya lebih generic sehingga modular. Counter Counter Tips: Kalau sumbernya ganti table likely ganti schema juga jadi bakal perlu tetep berubah. Tips: description diisi oleh engineer somewhere lalu integrated ke sini somehow Tips: wrap source dengan menggunakan sql query supaya kalau ada perubahan source bisa dihandle di sini. Caranya bikin model yang isinya cuma <code>SELECT * FROM source()</code>.</p>"},{"location":"chapter-1/source/#identifier","title":"Identifier","text":"<p>Kalau nama tablenya aneh, kita bisa pakai <code>identifier</code> sebagai nama table asli, dan <code>name</code> sebagai alias <pre><code>sources:\n  - name: jaffle_shop\n    database: raw  \n    schema: jaffle_shop  \n    tables:\n      - name: orders # nama yang kita pengen\n        identifier: nama_asli_tabel_yang_aneh\n</code></pre></p>"},{"location":"chapter-1/source/#quoting","title":"Quoting","text":"<p>Dalam beberapa kasus, query ke database mewajibkan kita untuk menambahkan quote di dalam query. Contohnya di Snowflake, nama table yang berasal dari reserved words perlu ditambahkan quote. Caranya adalah sebagai berikut.</p> <pre><code>sources:\n  - name: jaffle_shop\n    database: raw\n    quoting:\n      database: true\n      schema: true\n      identifier: true\n\n    tables:\n      - name: order # perlu diquote karena order adalah reserved words\n      - name: order_items\n        # This overrides the `jaffle_shop` quoting config\n        quoting:\n          identifier: false\n</code></pre>"},{"location":"chapter-1/source/#testing","title":"Testing","text":"<p>Source bisa kita cek apakah ada masalah atau tidak dengan kualitas datanya, misal di bawah ini dites apakah id-nya unique dan tidak null.</p> <p><pre><code>sources:\n  - name: jaffle_shop\n    description: This is a replica of the Postgres database used by our app\n    tables:\n      - name: orders\n        description: &gt;\n          One record per order. Includes cancelled and deleted orders.\n        columns:\n          - name: id\n            description: Primary key of the orders table\n            tests:\n              - unique\n              - not_null\n          - name: status\n            description: Note that the status can change over time\n</code></pre> Test semua source <pre><code>dbt test --select \"source:*\"\n</code></pre> Tes spesifik table <pre><code>dbt test --select source:jaffle_shop.orders\n</code></pre></p>"},{"location":"chapter-1/source/#running","title":"Running","text":"<p>Saat ada data dari sumber yang bermasalah, biasanya kita ingin menjalankan ulang semua pemrosesan yang terkait sumber tersebut. Caranya adalah menggunakan suffix <code>+</code>. Misal <pre><code>dbt run --select source:jaffle_shop.orders+\n</code></pre></p>"},{"location":"chapter-1/source/#freshness","title":"Freshness","text":"<p>Saat memproses data, tentu kita perlu mengecek apakah data yang kita akan proses sudah up-to-date atau belum. Misalkan kita memproses 100 sources, jika satu saja source out-dated, kita perlu memperoses ulang semuanya dan ini akan sangat costly. Maka dari itu, kita bisa menggunakan freshness. Deklarasi freshness menggunakan keyword <code>freshness</code> untuk konfigurasi seberapa sensitif terhadap ketertinggalan, dan <code>loaded_at_field</code> sebagai patokan kolom apa yang digunakan untuk mengecek waktu dibandingkan dengan waktu saat dijalankan. Freshness dapat dideklarasikan di level database maupun table. Contoh di bawah ini adalah deklarasi freshness di level table dengan <code>_etl_loaded_at</code> sebagai kolom untuk mengecek waktu.</p> <pre><code>sources:\n  - name: jaffle_shop\n    database: raw\n    tables:\n      - name: orders\n        freshness: # make this a little more strict\n          warn_after: {count: 6, period: hour}\n          error_after: {count: 12, period: hour}\n          filter: \"status = 'completed'\"\n        loaded_at_field: _etl_loaded_at\n</code></pre> <p>Dengan deklarasi di atas, saat kita menjalankan <code>dbt source freshness</code> atau <code>dbt source freshness --select source:jaffle_shop</code> misalnya, kita akan mendapatkan status fresheness untuk masing-masing table. Bisa dilihat juga bahwa kita bisa menggunakan <code>filter</code> untuk memilih kondisi apa yang akan digunakan saat mengecek freshness, dalam contoh di atas hanya yang statusnya <code>completed</code> saja. Jika ada table yang mau dikecualikan dari freshness, bisa dideklarasikan <code>freshness: null</code>.</p> <p>Lalu hasilnya bisa kita gunakan pada command build seperti berikut, misalnya untuk memproses ulang data yang lulus freshness check. <pre><code>dbt build --select source_status:fresher+\n</code></pre></p> <p>Hasil dari freshneess ini disimpan di <code>target/sources.json</code> dan bisa dibaca dengan menggunakan script misalnya dengan membaca json dengan python <code>sources[0].status == 'pass'</code>.</p> <pre><code>{\n  \"metadata\": {\n    \"generated_at\": \"2025-03-29T12:00:00Z\",\n    \"dbt_version\": \"1.7.0\"\n  },\n  \"sources\": [\n    {\n      \"source_name\": \"my_source\",\n      \"table_name\": \"my_table\",\n      \"max_loaded_at\": \"2025-03-29T08:00:00Z\",\n      \"snapshotted_at\": \"2025-03-29T12:00:00Z\",\n      \"status\": \"pass\",\n      \"max_loaded_at_time_ago_in_s\": 14400  # (4 hours ago)\n    }\n  ]\n}\n</code></pre>"}]}